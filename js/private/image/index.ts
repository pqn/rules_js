import { createReadStream, createWriteStream } from 'node:fs'
import { readdir, readFile, readlink, stat, access } from 'node:fs/promises'
import * as path from 'node:path'
import { Readable, Stream } from 'node:stream'
import { pathToFileURL } from 'node:url'
import { createGzip } from 'node:zlib'
import { pack, Pack } from 'tar-stream'

const MTIME = new Date(0)
const MODE_FOR_DIR = 0o755
const MODE_FOR_FILE = 0o555
const MODE_FOR_SYMLINK = 0o775

type HermeticStat = {
    mtime: Date
    mode: number
    size?: number
}

type Entry = {
    is_source: boolean
    is_directory: boolean
    is_external: boolean
    dest: string
    root?: string
    remove_non_hermetic_lines?: boolean
}
type Entries = { [path: string]: Entry }

type Compression = 'gzip' | 'none'

function findKeyByValue(entries: Entries, value: string): string | undefined {
    for (const [key, { dest: val }] of Object.entries(entries)) {
        if (val == value) {
            return key
        }
    }
    return undefined
}

async function isSymbolicLink(filep: string, root: string) {
    const p = path.resolve(filep);
    try {
        const firstHop = await readlink(p)
        // bazel symlinks files from execroot to sandbox execroot hence it's expected to
        // have a one level symlink.
        if (firstHop != p) {
            // if after one hop we are still in the execroot then we are on RBE or some bazel spawn
            // strategy that doesn't use symlinks.
            if (firstHop.startsWith(process.env.JS_BINARY__EXECROOT!)) {
                return firstHop
            }
            try {
                const secondHop = await readlink(firstHop)
                // if the first hop is not equal to second hop then it means
                // this is symlink generated by ctx.actions.symlink
                if (secondHop != firstHop) {
                    const execrootRelativePath = secondHop.slice(secondHop.indexOf(root));
					const isInTheSandbox = await access(execrootRelativePath).then(() => true).catch(() => false);
					if (!isInTheSandbox) {
						// this is a special case where the file is indeed a symlink but is not in either manifest or sandbox therefore 
						// doesn't have a corresponding path under the resulting tar file. We'll just treat it as a regular file
						return false;
					}
                    return secondHop
                }
            } catch (e) {
                if (e.code != 'EINVAL') {
                    throw e
                }
            }
        }
    } catch (e) {
        if (e.code != 'EINVAL') {
            throw e
        }
    }

    return false
}

async function* walk(dir: string, accumulate = '') {
    const dirents = await readdir(dir, { withFileTypes: true })
    for (const dirent of dirents) {
        let isDirectory = dirent.isDirectory()

        if (
            dirent.isSymbolicLink() &&
            !dirent.isDirectory() &&
            !dirent.isFile()
        ) {
            // On OSX we sometimes encounter this bug: https://github.com/nodejs/node/issues/30646
            // The entry is apparently a symlink, but it's ambiguous whether it's a symlink to a
            // file or to a directory, and lstat doesn't tell us either. Determine the type by
            // attempting to read it as a directory.

            try {
                await readdir(path.join(dir, dirent.name))
                isDirectory = true
            } catch (error) {
                if (error.code === 'ENOTDIR') {
                    isDirectory = false
                } else {
                    throw error
                }
            }
        }

        if (isDirectory) {
            yield* walk(
                path.join(dir, dirent.name),
                path.join(accumulate, dirent.name)
            )
        } else {
            yield path.join(accumulate, dirent.name)
        }
    }
}

function add_parents(name: string, pkg: Pack, existing_paths: Set<string>) {
    const segments = path.dirname(name).split('/')
    let prev = ''
    const stats: HermeticStat = {
        // this is an intermediate directory and bazel does not allow specifying
        // modes for intermediate directories.
        mode: MODE_FOR_DIR,
        mtime: MTIME,
    }
    for (const part of segments) {
        if (!part) {
            continue
        }
        prev = path.join(prev, part)
        // check if the directory has been has been created before.
        if (existing_paths.has(prev)) {
            continue
        }

        existing_paths.add(prev)
        add_directory(prev, pkg, stats)
    }
}

function add_directory(name: string, pkg: Pack, stats: HermeticStat) {
    pkg.entry({
        type: 'directory',
        name: name.replace(/^\//, ''),
        mode: stats.mode,
        mtime: MTIME,
    }).end()
}

function add_symlink(
    name: string,
    linkname: string,
    pkg: Pack,
    stats: HermeticStat
) {
    pkg.entry({
        type: 'symlink',
        name: name.replace(/^\//, ''),
        linkname: linkname,
        mode: stats.mode,
        mtime: MTIME,
    }).end()
}

function add_file(
    name: string,
    content: Readable,
    pkg: Pack,
    stats: HermeticStat
) {
    return new Promise((resolve, reject) => {
        const entry = pkg.entry(
            {
                type: 'file',
                name: name.replace(/^\//, ''),
                mode: stats.mode,
                size: stats.size,
                mtime: MTIME,
            },
            (err) => {
                if (err) {
                    reject(err)
                } else {
                    resolve(undefined)
                }
            }
        )
        content.pipe(entry)
    })
}

export async function build(
    entries: Entries,
    appLayerPath: string,
    nodeModulesLayerPath: string,
    compression: Compression
) {
    const app = pack()
    const nm = pack()

    const app_existing_paths = new Set<string>()
    const nm_existing_paths = new Set<string>()

    let app_output: Stream = app,
        nm_output: Stream = nm

    if (compression == 'gzip') {
        app_output = app_output.pipe(createGzip())
        nm_output = nm_output.pipe(createGzip())
    }

    app_output.pipe(createWriteStream(appLayerPath))
    nm_output.pipe(createWriteStream(nodeModulesLayerPath))

    for (const key of Object.keys(entries).sort()) {
        const {
            dest,
            is_directory,
            is_source,
            is_external,
            root,
            remove_non_hermetic_lines,
        } = entries[key]

        const output = dest.indexOf('node_modules') != -1 ? nm : app
        const existing_paths =
            dest.indexOf('node_modules') != -1
                ? nm_existing_paths
                : app_existing_paths

        // its a treeartifact. expand it and add individual entries.
        if (is_directory) {
            for await (const sub_key of walk(dest)) {
                const new_key = path.join(key, sub_key)
                const new_dest = path.join(dest, sub_key)

                add_parents(new_key, output, existing_paths)

                const stats = await stat(new_dest)
                await add_file(
                    new_key,
                    createReadStream(new_dest),
                    output,
                    stats
                )
            }
            continue
        }

        // create parents of current path.
        add_parents(key, output, existing_paths)

        // A source file from workspace, not an output of a target.
        if (is_source) {
            const originalStat = await stat(dest)
            // use stable mode bits instead of preserving the one from file.
            const stats: HermeticStat = {
                mode: MODE_FOR_FILE,
                mtime: MTIME,
                size: originalStat.size,
            }
            await add_file(key, createReadStream(dest), output, stats)
            continue
        }

        // root indicates where the generated source comes from. it looks like
        // `bazel-out/darwin_arm64-fastbuild` when there's no transition.
        if (!root) {
            // everything except sources should have
            throw new Error(
                `unexpected entry format. ${JSON.stringify(
                    entries[key]
                )}. please file a bug at https://github.com/aspect-build/rules_js/issues/new/choose`
            )
        }

        const realp = await isSymbolicLink(dest, root)

        // it's important that we don't treat any symlink pointing out of execroot since
        // bazel symlinks external files into sandbox to make them available to us.
        if (realp && !is_external) {
            const output_path = realp.slice(realp.indexOf(root))
            // interestingly, bazel 5 and 6 sets different mode bits on symlinks.
            // well use `0o755` to allow owner&group to `rwx` and others `rx`
            // see: https://chmodcommand.com/chmod-775/
            // const stats = await stat(dest)
            const stats: HermeticStat = { mode: MODE_FOR_SYMLINK, mtime: MTIME }
            const linkname = findKeyByValue(entries, output_path)
            if (linkname == undefined) {
                throw new Error(
                    `Couldn't map symbolic link ${output_path} to a path. please file a bug at https://github.com/aspect-build/rules_js/issues/new/choose\n\n` +
                        `dest: ${dest}\n` +
                        `realpath: ${realp}\n` +
                        `outputpath: ${output_path}\n` +
                        `root: ${root}\n` +
                        `runfiles: ${key}\n\n`
                )
            }
            add_symlink(key, linkname, output, stats)
        } else {
            // Due to filesystems setting different bits depending on the os we have to opt-in
            // to use a stable mode for files.
            // In the future, we might want to hand off fine-grained control of these to users
            // see: https://chmodcommand.com/chmod-0555/
            const originalStat = await stat(dest)
            const stats: HermeticStat = {
                mode: MODE_FOR_FILE,
                mtime: MTIME,
                size: originalStat.size,
            }
            let stream: Readable = createReadStream(dest)

            if (remove_non_hermetic_lines) {
                const content = await readFile(dest)
                const replaced = Buffer.from(
                    content
                        .toString()
                        .replace(
                            /.*JS_BINARY__TARGET_CPU=".*?"/g,
                            `export JS_BINARY__TARGET_CPU="$(uname -m)"`
                        )
                        .replace(
                            /.*JS_BINARY__BINDIR=".*"/g,
                            `export JS_BINARY__BINDIR="$(pwd)"`
                        )
                )
                stream = Readable.from(replaced)
                stats.size = replaced.byteLength
            }

            await add_file(key, stream, output, stats)
        }
    }

    app.finalize()
    nm.finalize()
}

if (import.meta.url === pathToFileURL(process.argv[1]).href) {
    const [entriesPath, appLayerPath, nodeModulesLayerPath, compression] =
        process.argv.slice(2)

    const raw_entries = await readFile(entriesPath)
    const entries: Entries = JSON.parse(raw_entries.toString())
    build(
        entries,
        appLayerPath,
        nodeModulesLayerPath,
        compression as Compression
    )
}
